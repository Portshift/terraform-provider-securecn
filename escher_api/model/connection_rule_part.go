// Code generated by go-swagger; DO NOT EDIT.

package model

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"bytes"
	"encoding/json"
	"io"
	"io/ioutil"

	strfmt "github.com/go-openapi/strfmt"

	"github.com/go-openapi/errors"
	"github.com/go-openapi/runtime"
	"github.com/go-openapi/validate"
)

// ConnectionRulePart connection rule part
// swagger:discriminator ConnectionRulePart connectionRulePartType
type ConnectionRulePart interface {
	runtime.Validatable

	// connection rule part type
	// Required: true
	// Enum: [AppNameConnectionRulePart AppTypeConnectionRulePart AppLabelConnectionRulePart AppAnyConnectionRulePart PodNameConnectionRulePart PodLablesConnectionRulePart PodAnyConnectionRulePart ExpansionNameConnectionRulePart ExpansionLabelsConnectionRulePart ExpansionAnyConnectionRulePart EnvironmentNameConnectionRulePart EnvironmentAnyConnectionRulePart EnvironmentRiskConnectionRulePart IpRangeConnectionRulePart ExternalConnectionRulePart FqdnConnectionRulePart ServiceNameConnectionRulePart AnyConnectionRulePart]
	ConnectionRulePartType() string
	SetConnectionRulePartType(string)
}

type connectionRulePart struct {
	connectionRulePartTypeField string
}

// ConnectionRulePartType gets the connection rule part type of this polymorphic type
func (m *connectionRulePart) ConnectionRulePartType() string {
	return "ConnectionRulePart"
}

// SetConnectionRulePartType sets the connection rule part type of this polymorphic type
func (m *connectionRulePart) SetConnectionRulePartType(val string) {

}

// UnmarshalConnectionRulePartSlice unmarshals polymorphic slices of ConnectionRulePart
func UnmarshalConnectionRulePartSlice(reader io.Reader, consumer runtime.Consumer) ([]ConnectionRulePart, error) {
	var elements []json.RawMessage
	if err := consumer.Consume(reader, &elements); err != nil {
		return nil, err
	}

	var result []ConnectionRulePart
	for _, element := range elements {
		obj, err := unmarshalConnectionRulePart(element, consumer)
		if err != nil {
			return nil, err
		}
		result = append(result, obj)
	}
	return result, nil
}

// UnmarshalConnectionRulePart unmarshals polymorphic ConnectionRulePart
func UnmarshalConnectionRulePart(reader io.Reader, consumer runtime.Consumer) (ConnectionRulePart, error) {
	// we need to read this twice, so first into a buffer
	data, err := ioutil.ReadAll(reader)
	if err != nil {
		return nil, err
	}
	return unmarshalConnectionRulePart(data, consumer)
}

func unmarshalConnectionRulePart(data []byte, consumer runtime.Consumer) (ConnectionRulePart, error) {
	buf := bytes.NewBuffer(data)
	buf2 := bytes.NewBuffer(data)

	// the first time this is read is to fetch the value of the connectionRulePartType property.
	var getType struct {
		ConnectionRulePartType string `json:"connectionRulePartType"`
	}
	if err := consumer.Consume(buf, &getType); err != nil {
		return nil, err
	}

	if err := validate.RequiredString("connectionRulePartType", "body", getType.ConnectionRulePartType); err != nil {
		return nil, err
	}

	// The value of connectionRulePartType is used to determine which type to create and unmarshal the data into
	switch getType.ConnectionRulePartType {
	case "AnyConnectionRulePart":
		var result AnyConnectionRulePart
		if err := consumer.Consume(buf2, &result); err != nil {
			return nil, err
		}
		return &result, nil

	case "AppAnyConnectionRulePart":
		var result AppAnyConnectionRulePart
		if err := consumer.Consume(buf2, &result); err != nil {
			return nil, err
		}
		return &result, nil

	case "AppLabelConnectionRulePart":
		var result AppLabelConnectionRulePart
		if err := consumer.Consume(buf2, &result); err != nil {
			return nil, err
		}
		return &result, nil

	case "AppNameConnectionRulePart":
		var result AppNameConnectionRulePart
		if err := consumer.Consume(buf2, &result); err != nil {
			return nil, err
		}
		return &result, nil

	case "AppTypeConnectionRulePart":
		var result AppTypeConnectionRulePart
		if err := consumer.Consume(buf2, &result); err != nil {
			return nil, err
		}
		return &result, nil

	case "ConnectionRulePart":
		var result connectionRulePart
		if err := consumer.Consume(buf2, &result); err != nil {
			return nil, err
		}
		return &result, nil

	case "EnvironmentAnyConnectionRulePart":
		var result EnvironmentAnyConnectionRulePart
		if err := consumer.Consume(buf2, &result); err != nil {
			return nil, err
		}
		return &result, nil

	case "EnvironmentNameConnectionRulePart":
		var result EnvironmentNameConnectionRulePart
		if err := consumer.Consume(buf2, &result); err != nil {
			return nil, err
		}
		return &result, nil

	case "EnvironmentRiskConnectionRulePart":
		var result EnvironmentRiskConnectionRulePart
		if err := consumer.Consume(buf2, &result); err != nil {
			return nil, err
		}
		return &result, nil

	case "ExternalConnectionRulePart":
		var result ExternalConnectionRulePart
		if err := consumer.Consume(buf2, &result); err != nil {
			return nil, err
		}
		return &result, nil

	case "FqdnConnectionRulePart":
		var result FqdnConnectionRulePart
		if err := consumer.Consume(buf2, &result); err != nil {
			return nil, err
		}
		return &result, nil

	case "IpRangeConnectionRulePart":
		var result IPRangeConnectionRulePart
		if err := consumer.Consume(buf2, &result); err != nil {
			return nil, err
		}
		return &result, nil

	case "PodAnyConnectionRulePart":
		var result PodAnyConnectionRulePart
		if err := consumer.Consume(buf2, &result); err != nil {
			return nil, err
		}
		return &result, nil

	case "PodLablesConnectionRulePart":
		var result PodLablesConnectionRulePart
		if err := consumer.Consume(buf2, &result); err != nil {
			return nil, err
		}
		return &result, nil

	case "PodNameConnectionRulePart":
		var result PodNameConnectionRulePart
		if err := consumer.Consume(buf2, &result); err != nil {
			return nil, err
		}
		return &result, nil

	case "ServiceNameConnectionRulePart":
		var result ServiceNameConnectionRulePart
		if err := consumer.Consume(buf2, &result); err != nil {
			return nil, err
		}
		return &result, nil

	}
	return nil, errors.New(422, "invalid connectionRulePartType value: %q", getType.ConnectionRulePartType)

}

// Validate validates this connection rule part
func (m *connectionRulePart) Validate(formats strfmt.Registry) error {
	return nil
}
