package securecn

import (
	"bytes"
	"context"
	"errors"
	"fmt"
	"io"
	"log"
	"net/http"
	"os"
	"strings"

	"github.com/go-openapi/strfmt"
	"github.com/hashicorp/terraform-plugin-sdk/v2/diag"
	"github.com/hashicorp/terraform-plugin-sdk/v2/helper/schema"
	"github.com/hashicorp/terraform-plugin-sdk/v2/helper/validation"
	"github.com/spf13/cast"

	"terraform-provider-securecn/client"
	"terraform-provider-securecn/escher_api/escherClient"
	escherModel "terraform-provider-securecn/escher_api/model"
	"terraform-provider-securecn/utils"
)

const secureCNBundleFilePath = "securecn_bundle.tar.gz"
const scriptFilePath = "install_bundle.sh"
const yamlFilePath = "securecn_bundle.yml"
const patchDnsFilePath = "patch_dns.sh"
const certsGenFilePath = "certs_gen.sh"
const vaultCertsGenFilePath = "certs_gen_vault.sh"
const vaultCertsFolder = "vault_certs"
const uninstallAgentCommand = "kubectl get cm -n portshift portshift-uninstaller -o jsonpath='{.data.config}' | bash"
const getCurrentK8ContextCommand = "kubectl config current-context"
const useK8ContextCommandFormat = "kubectl config use-context %s"
const kubectlGetAllContextsCommand = "kubectl config view -o jsonpath='{.contexts[*].name}'"

const KubernetesClusterContextFieldName = "kubernetes_cluster_context"
const NameFieldName = "name"
const CiImageValidationFieldName = "ci_image_validation"
const RestrictRegistries = "restrict_registries"
const CdPodTemplateFieldName = "cd_pod_template"
const ConnectionsControlFieldName = "connections_control"
const IstioVersionFieldName = "istio_version"
const IstioIngressEnabledFieldName = "istio_ingress_enabled"
const IstioIngressAnnotationsFieldName = "istio_ingress_annotations"
const EnableVenafiIntegrationFieldName = "venafi_integration"
const EnableApiIntelligenceDASTFieldName = "api_intelligence_dast"
const EnableAutoLabelFieldName = "auto_labeling"
const HoldApplicationUntilProxyStartsFieldName = "hold_application_until_proxy_starts"
const ExternalCAFieldName = "external_ca"
const InternalRegistryFieldName = "internal_registry"
const ServiceDiscoveryIsolationFieldName = "service_discovery_isolation"
const TLSInspectionFieldName = "tls_inspection"
const TokenInjectionFieldName = "token_injection"
const TraceAnalyzerFieldName = "trace_analyzer"
const SidecarResourcesFieldName = "sidecar_resources"
const MultiClusterCommunicationSupportFieldName = "multi_cluster_communication_support"
const MultiClusterCommunicationSupportCertsPathFieldName = MultiClusterCommunicationSupportFieldName + "_certs_path"
const InspectIncomingClusterConnectionsFieldName = "inspect_incoming_cluster_connections"
const FailCloseFieldName = "fail_close"
const PersistentStorageFieldName = "persistent_storage"
const ExternalHttpsProxyFieldName = "external_https_proxy"
const OrchestrationTypeFieldName = "orchestration_type"

func ResourceCluster() *schema.Resource {
	return &schema.Resource{
		CreateContext: resourceClusterCreate,
		ReadContext:   resourceClusterRead,
		UpdateContext: resourceClusterUpdate,
		DeleteContext: resourceClusterDelete,
		Description:   "A SecureCN k8s cluster",
		Schema: map[string]*schema.Schema{
			KubernetesClusterContextFieldName: {Type: schema.TypeString, Required: true, ForceNew: true, Description: "The k8s context name of the cluster",
				ValidateFunc: func(val interface{}, key string) (warns []string, errs []error) {
					k8sContext := val.(string)
					output, _ := utils.ExecBashCommand(kubectlGetAllContextsCommand)
					allContexts := strings.Split(output, " ")
					if !(utils.ContainsString(allContexts, k8sContext)) {
						errs = append(errs, fmt.Errorf("k8sContext %s does not exist", k8sContext))
					}
					return
				},
			},
			NameFieldName:                             {Type: schema.TypeString, Required: true, Description: "The name of cluster in SecureCN"},
			CiImageValidationFieldName:                {Type: schema.TypeBool, Optional: true, Default: false, Description: "Identify pods only if the image hash matches the value generated by the CI plugin or entered manually in the UI"},
			CdPodTemplateFieldName:                    {Type: schema.TypeBool, Optional: true, Default: false, Description: "Identify pod templates only originating from SecureCN CD plugin"},
			RestrictRegistries:                        {Type: schema.TypeBool, Optional: true, Default: false, Description: "Workload from untrusted registries will be marked as 'unknown'"},
			ConnectionsControlFieldName:               {Type: schema.TypeBool, Optional: true, Default: true, Description: "Enable connections control"},
			IstioVersionFieldName:                     {Type: schema.TypeString, Optional: true, Default: nil, Computed: true, Description: "When installing SecureCN agent deployment, use the already existing Istio deployment"},
			IstioIngressEnabledFieldName:              {Type: schema.TypeBool, Optional: true, Computed: true, Description: "If installing Istio, use Istio ingress"},
			IstioIngressAnnotationsFieldName:          {Type: schema.TypeMap, Elem: schema.TypeString, Optional: true, Default: map[string]string{}, Description: "If enabling Istio ingress, use Istio these ingress annotation"},
			MultiClusterCommunicationSupportFieldName: {Type: schema.TypeBool, Optional: true, Default: false, Description: "Enable multi cluster communication"},
			MultiClusterCommunicationSupportCertsPathFieldName: {Type: schema.TypeString, Optional: true, Default: "", Description: "Multi cluster certs path. Only valid if " + MultiClusterCommunicationSupportFieldName + " is true",
				ValidateFunc: func(val interface{}, key string) (warns []string, errs []error) {
					path := val.(string)
					if _, err := os.Stat(path); path != "" && os.IsNotExist(err) {
						errs = append(errs, fmt.Errorf("folder %s does not exist", path))
					}
					return
				},
			},
			InspectIncomingClusterConnectionsFieldName: {Type: schema.TypeBool, Optional: true, Default: false, Description: "Enable enforcement and visibility of connections from external IP sources"},
			FailCloseFieldName:                         {Type: schema.TypeBool, Optional: true, Default: false, Description: "When enabled, workloads and connections will be blocked in case SecureCN agent is not responding"},
			PersistentStorageFieldName:                 {Type: schema.TypeBool, Optional: true, Default: true, Description: "Allow SecureCN agent to save the policy persistently, so it will be available after a restart of the pod. This will Require 128MB of storage for the agent pod."},
			ExternalHttpsProxyFieldName:                {Type: schema.TypeString, Optional: true, Default: "", Description: "Proxy definitions for outgoing HTTPS traffic from the cluster, if needed"},
			OrchestrationTypeFieldName: {Type: schema.TypeString, Optional: true, Default: "KUBERNETES", Description: "Orchestration type of the kubernetes cluster",
				ValidateFunc: validation.StringInSlice([]string{
					"GKE", "OPENSHIFT", "RANCHER", "AKS", "EKS", "KUBERNETES", "IKS",
				}, true),
			},
			EnableVenafiIntegrationFieldName:         {Type: schema.TypeBool, Optional: true, Default: false, Description: "Enable Venafi integration"},
			EnableApiIntelligenceDASTFieldName:       {Type: schema.TypeBool, Optional: true, Default: false, Description: "Enable API Intelligence DAST integration"},
			EnableAutoLabelFieldName:                 {Type: schema.TypeBool, Optional: true, Default: false, Description: "Enable auto labeling of Kubernetes namespaces"},
			HoldApplicationUntilProxyStartsFieldName: {Type: schema.TypeBool, Optional: true, Default: false, Description: "Indicates whether the controller should hold the application until the proxy starts"},
			ServiceDiscoveryIsolationFieldName:       {Type: schema.TypeBool, Optional: true, Default: false, Description: "Indicates whether the service discovery isolation is enabled"},
			TLSInspectionFieldName:                   {Type: schema.TypeBool, Optional: true, Computed: true, Description: "Indicates whether the TLS inspection is enabled"},
			TokenInjectionFieldName:                  {Type: schema.TypeBool, Optional: true, Default: false, Description: "Indicates whether the token injection is enabled"},
			TraceAnalyzerFieldName:                   {Type: schema.TypeBool, Optional: true, Default: false, Description: "Indicates whether the trace analyzer is enabled"},
			ExternalCAFieldName: {
				Description: "Use an external CA for this cluster",
				Optional:    true,
				Type:        schema.TypeList,
				MaxItems:    1,
				Elem: &schema.Resource{
					Schema: map[string]*schema.Schema{
						"id": {
							Description:  "The id of the external CA",
							Type:         schema.TypeString,
							Required:     true,
							ValidateFunc: validation.IsUUID,
						},
						"name": {
							Description: "The name of the external CA",
							Optional:    true,
							Type:        schema.TypeString,
						},
					},
				},
			},
			InternalRegistryFieldName: {
				Description: "Use an internal container registry for this cluster",
				Optional:    true,
				Type:        schema.TypeList,
				MaxItems:    1,
				Elem: &schema.Resource{
					Schema: map[string]*schema.Schema{
						"url": {
							Description: "The url of the internal registry",
							Type:        schema.TypeString,
							Required:    true,
						},
					},
				},
			},
			SidecarResourcesFieldName: {
				Description: "Define resource limits for Istio sidecars",
				Optional:    true,
				Type:        schema.TypeList,
				MaxItems:    1,
				Elem: &schema.Resource{
					Schema: map[string]*schema.Schema{
						"proxy_init_limits_cpu": {
							Type:     schema.TypeInt,
							Optional: true,
						},
						"proxy_init_limits_memory": {
							Type:     schema.TypeInt,
							Optional: true,
						},
						"proxy_init_requests_cpu": {
							Type:     schema.TypeInt,
							Optional: true,
						},
						"proxy_init_requests_memory": {
							Type:     schema.TypeInt,
							Optional: true,
						},
						"proxy_limits_cpu": {
							Type:     schema.TypeInt,
							Optional: true,
						},
						"proxy_limits_memory": {
							Type:     schema.TypeInt,
							Optional: true,
						},
						"proxy_requests_cpu": {
							Type:     schema.TypeInt,
							Optional: true,
						},
						"proxy_requests_memory": {
							Type:     schema.TypeInt,
							Optional: true,
						},
					},
				},
			},
		},
	}
}

func resourceClusterCreate(ctx context.Context, d *schema.ResourceData, m interface{}) diag.Diagnostics {
	log.Print("[DEBUG] creating cluster")

	err := validateConfig(d)
	if err != nil {
		return diag.FromErr(err)
	}

	httpClientWrapper := m.(client.HttpClientWrapper)

	serviceApi := utils.GetServiceApi(&httpClientWrapper)

	kubernetesCluster, err := getClusterFromConfig(d)
	if err != nil {
		return diag.FromErr(err)
	}

	secureCNCluster, err := serviceApi.CreateKubernetesCluster(ctx, httpClientWrapper.HttpClient, kubernetesCluster)
	if err != nil {
		return diag.FromErr(err)
	}

	clusterId := secureCNCluster.Payload.ID
	k8sContext := d.Get(KubernetesClusterContextFieldName).(string)
	multiClusterFolder := d.Get(MultiClusterCommunicationSupportCertsPathFieldName).(string)
	tokenInjection := d.Get(TokenInjectionFieldName).(bool)

	err = installAgent(ctx, serviceApi, httpClientWrapper, clusterId, k8sContext, multiClusterFolder, tokenInjection)
	if err != nil {
		return diag.FromErr(err)
	}

	d.SetId(string(clusterId))
	return resourceClusterRead(ctx, d, m)
}

func resourceClusterRead(ctx context.Context, d *schema.ResourceData, m interface{}) diag.Diagnostics {
	log.Print("[DEBUG] reading cluster")

	httpClientWrapper := m.(client.HttpClientWrapper)

	serviceApi := utils.GetServiceApi(&httpClientWrapper)
	clusterId := d.Id()

	secureCNCluster, err := serviceApi.GetKubernetesClusterById(ctx, httpClientWrapper.HttpClient, strfmt.UUID(clusterId))
	if err != nil {
		return diag.FromErr(err)
	}

	if secureCNCluster.Payload.ID == "" {
		// Tell terraform the cluster doesn't exist
		d.SetId("")
	} else {
		kubernetesClusterFromConfig, err := getClusterFromConfig(d)
		if err != nil {
			return diag.FromErr(err)
		}
		k8sContext := d.Get(KubernetesClusterContextFieldName).(string)
		certsFolder := d.Get(MultiClusterCommunicationSupportCertsPathFieldName).(string)
		tokenInjection := d.Get(TokenInjectionFieldName).(bool)
		err = updateAgent(k8sContext, certsFolder, kubernetesClusterFromConfig, tokenInjection, *secureCNCluster.Payload.IsMultiCluster, *secureCNCluster.Payload.EnableConnectionsControl, *secureCNCluster.Payload.AgentFailClose, *secureCNCluster.Payload.IsPersistent, *secureCNCluster.Payload.ProxyConfiguration, serviceApi, httpClientWrapper, strfmt.UUID(clusterId))
		if err != nil {
			return diag.FromErr(err)
		}
		updateMutableFields(d, secureCNCluster.Payload)
	}

	return nil
}

func resourceClusterUpdate(ctx context.Context, d *schema.ResourceData, m interface{}) diag.Diagnostics {
	log.Print("[DEBUG] updating cluster")

	err := validateConfig(d)
	if err != nil {
		return diag.FromErr(err)
	}

	httpClientWrapper := m.(client.HttpClientWrapper)

	serviceApi := utils.GetServiceApi(&httpClientWrapper)

	kubernetesClusterFromConfig, err := getClusterFromConfig(d)
	if err != nil {
		return diag.FromErr(err)
	}

	clusterId := d.Id()
	updatedCluster, err := serviceApi.UpdateKubernetesCluster(ctx, httpClientWrapper.HttpClient, kubernetesClusterFromConfig, strfmt.UUID(clusterId))
	if err != nil {
		return diag.FromErr(err)
	}

	kubernetesClusterFromConfig, err = getClusterFromConfig(d)
	if err != nil {
		return diag.FromErr(err)
	}

	k8sContext := d.Get(KubernetesClusterContextFieldName).(string)
	certsFolder := d.Get(MultiClusterCommunicationSupportCertsPathFieldName).(string)
	tokenInjection := d.Get(TokenInjectionFieldName).(bool)

	err = updateAgent(k8sContext, certsFolder, kubernetesClusterFromConfig, tokenInjection, *updatedCluster.Payload.IsMultiCluster, *updatedCluster.Payload.EnableConnectionsControl, *updatedCluster.Payload.AgentFailClose, *updatedCluster.Payload.IsPersistent, *updatedCluster.Payload.ProxyConfiguration, serviceApi, httpClientWrapper, strfmt.UUID(clusterId)) //TODO update other fields, tests
	if err != nil {
		return diag.FromErr(err)
	}

	d.SetId(string(updatedCluster.Payload.ID))
	return resourceClusterRead(ctx, d, m)
}

func resourceClusterDelete(ctx context.Context, d *schema.ResourceData, m interface{}) diag.Diagnostics {
	log.Print("[DEBUG] deleting cluster")

	httpClientWrapper := m.(client.HttpClientWrapper)

	serviceApi := utils.GetServiceApi(&httpClientWrapper)
	clusterId := strfmt.UUID(d.Id())

	k8sContext := d.Get(KubernetesClusterContextFieldName).(string)
	err := deleteAgent(k8sContext)
	if err != nil {
		return diag.FromErr(err)
	}

	err = serviceApi.DeleteKubernetesCluster(ctx, httpClientWrapper.HttpClient, clusterId)
	if err != nil {
		return diag.FromErr(err)
	}

	// Tell terraform the cluster doesn't exist
	d.SetId("")

	return nil
}

func installAgent(ctx context.Context, serviceApi *escherClient.MgmtServiceApiCtx, httpClientWrapper client.HttpClientWrapper, clusterId strfmt.UUID, context string, multiClusterFolder string, tokenInjection bool) error {
	log.Print("[DEBUG] installing agent")
	err := downloadAndExtractBundle(ctx, serviceApi, httpClientWrapper, clusterId)
	if err != nil {
		return err
	}

	if tokenInjection {
		err = utils.MakeExecutable(vaultCertsGenFilePath)
		if err != nil {
			return err
		}
	}

	currentContext, err := utils.ExecBashCommand(getCurrentK8ContextCommand)
	if err != nil {
		return err
	}

	err = changeK8Context(context, err)
	if err != nil {
		return err
	}

	_, err = utils.ExecuteScript(scriptFilePath, multiClusterFolder)
	log.Print("[DEBUG] agent installed successfully")

	if err != nil {
		_ = changeK8Context(currentContext, err)
		return err
	}

	err = changeK8Context(currentContext, err)
	if err != nil {
		return err
	}

	defer os.Remove(yamlFilePath)
	defer os.Remove(scriptFilePath)

	if multiClusterFolder != "" {
		defer os.Remove(patchDnsFilePath)
		defer os.Remove(certsGenFilePath)
	}

	if tokenInjection {
		defer os.Remove(vaultCertsGenFilePath)
		defer os.RemoveAll(vaultCertsFolder)
	}

	return nil
}

func deleteAgent(context string) error {
	log.Printf("[DEBUG] deleting agent from context: " + context)

	currentContext, err := utils.ExecBashCommand(getCurrentK8ContextCommand)
	if err != nil {
		return err
	}

	err = changeK8Context(context, err)
	if err != nil {
		return err
	}

	_, err = utils.ExecBashCommand(uninstallAgentCommand)
	if err != nil {
		_ = changeK8Context(currentContext, err)
		return err
	}

	err = changeK8Context(currentContext, err)
	if err != nil {
		return err
	}

	return nil
}

func changeK8Context(context string, err error) error {
	log.Print("[DEBUG] changing k8s context to " + context)
	changeContextCommand := fmt.Sprintf(useK8ContextCommandFormat, context)
	_, err = utils.ExecBashCommand(changeContextCommand)

	if err != nil {
		log.Print("[DEBUG] failed to change k8s context: " + err.Error())
		return err
	}

	return nil
}

func downloadAndExtractBundle(ctx context.Context, serviceApi *escherClient.MgmtServiceApiCtx, httpClientWrapper client.HttpClientWrapper, clusterId strfmt.UUID) error {
	log.Print("[DEBUG] downloading and extracting bundle")
	err := downloadFile(ctx, serviceApi, httpClientWrapper.HttpClient, clusterId)
	if err != nil {
		return err
	}
	open, err := os.Open(secureCNBundleFilePath)
	if err != nil {
		return err
	}
	defer os.Remove(secureCNBundleFilePath)

	err = utils.ExtractTarGz(open)
	if err != nil {
		return err
	}
	return nil
}

func getClusterFromConfig(d *schema.ResourceData) (*escherModel.KubernetesCluster, error) {
	log.Print("[DEBUG] getting cluster from config")

	clusterName := d.Get(NameFieldName).(string)
	ciImageValidation := d.Get(CiImageValidationFieldName).(bool)
	cdPodTemplate := d.Get(CdPodTemplateFieldName).(bool)
	restrictRegistries := d.Get(RestrictRegistries).(bool)
	connectionsControl := d.Get(ConnectionsControlFieldName).(bool)
	istioVersion := d.Get(IstioVersionFieldName).(string)
	istioIngressEnabled := d.Get(IstioIngressEnabledFieldName).(bool)
	istioIngressAnnotationsRaw := cast.ToStringMapString(d.Get(IstioIngressAnnotationsFieldName))
	var istioIngressAnnotations []*escherModel.KubernetesAnnotation
	for k, v := range istioIngressAnnotationsRaw {
		istioIngressAnnotations = append(istioIngressAnnotations, &escherModel.KubernetesAnnotation{
			Key:   &k,
			Value: &v,
		})
	}
	supportsMultiClusterCommunication := d.Get(MultiClusterCommunicationSupportFieldName).(bool)
	inspectIncomingClusterConnections := d.Get(InspectIncomingClusterConnectionsFieldName).(bool)
	failClose := d.Get(FailCloseFieldName).(bool)
	persistentStorage := d.Get(PersistentStorageFieldName).(bool)
	externalHttpsProxy := d.Get(ExternalHttpsProxyFieldName).(string)
	orchestrationType := d.Get(OrchestrationTypeFieldName).(string)

	isIstioAlreadyInstalled := istioVersion != ""
	enableProxy := externalHttpsProxy != ""
	clusterPodDefinitionSource := escherModel.ClusterPodDefinitionSourceKUBERNETES
	if cdPodTemplate {
		clusterPodDefinitionSource = escherModel.ClusterPodDefinitionSourceCD
	}

	proxyConfig := &escherModel.ProxyConfiguration{
		EnableProxy: &enableProxy,
		HTTPSProxy:  externalHttpsProxy,
	}
	istioParams := &escherModel.IstioInstallationParameters{
		IsIstioAlreadyInstalled: &isIstioAlreadyInstalled,
		IstioVersion:            istioVersion,
	}
	enableVenafiIntegration := d.Get(EnableVenafiIntegrationFieldName).(bool)
	enableAPIIntelligenceDAST := d.Get(EnableApiIntelligenceDASTFieldName).(bool)
	enableAutoLabel := d.Get(EnableAutoLabelFieldName).(bool)
	holdApplicationUntilProxyStarts := d.Get(HoldApplicationUntilProxyStartsFieldName).(bool)
	enableServiceDiscoveryIsolation := d.Get(ServiceDiscoveryIsolationFieldName).(bool)
	enableTLSInspection := d.Get(TLSInspectionFieldName).(bool)
	enableTokenInjection := d.Get(TokenInjectionFieldName).(bool)
	enableTraceAnalyzer := d.Get(TraceAnalyzerFieldName).(bool)
	cluster := &escherModel.KubernetesCluster{
		AgentFailClose:                    &failClose,
		CiImageValidation:                 &ciImageValidation,
		RestrictRegistires:                &restrictRegistries,
		ClusterPodDefinitionSource:        clusterPodDefinitionSource,
		EnableConnectionsControl:          &connectionsControl,
		ID:                                "",
		IsMultiCluster:                    &supportsMultiClusterCommunication,
		IsPersistent:                      &persistentStorage,
		IstioInstallationParameters:       istioParams,
		IsIstioIngressEnabled:             &istioIngressEnabled,
		IstioIngressAnnotations:           istioIngressAnnotations,
		Name:                              &clusterName,
		PreserveOriginalSourceIP:          &inspectIncomingClusterConnections,
		ProxyConfiguration:                proxyConfig,
		OrchestrationType:                 &orchestrationType,
		EnableVenafiIntegration:           &enableVenafiIntegration,
		APIIntelligenceDAST:               &enableAPIIntelligenceDAST,
		AutoLabelEnabled:                  &enableAutoLabel,
		IsHoldApplicationUntilProxyStarts: &holdApplicationUntilProxyStarts,
		ServiceDiscoveryIsolationEnabled:  &enableServiceDiscoveryIsolation,
		TLSInspectionEnabled:              &enableTLSInspection,
		TokenInjectionEnabled:             &enableTokenInjection,
		TraceAnalyzerEnabled:              &enableTraceAnalyzer,
	}

	externalCaId := utils.ReadNestedStringFromTF(d, ExternalCAFieldName, "id", 0)
	externalCaName := utils.ReadNestedStringFromTF(d, ExternalCAFieldName, "name", 0)
	if externalCaId != "" {
		cluster.ExternalCa = &escherModel.ExternalCaDetails{
			ID:   strfmt.UUID(externalCaId),
			Name: externalCaName,
		}
	}

	internalRegistryUrl := utils.ReadNestedStringFromTF(d, InternalRegistryFieldName, "url", 0)
	if internalRegistryUrl != "" {
		internalRegistryEnabled := true
		cluster.InternalRegistryParameters = &escherModel.InternalRegistryParameters{
			InternalRegistryEnabled: &internalRegistryEnabled,
			InternalRegistry:        internalRegistryUrl,
		}
	}

	proxyInitLimitsCpu := utils.ReadNestedIntFromTF(d, SidecarResourcesFieldName, "proxy_init_limits_cpu", 0)
	proxyInitLimitsMemory := utils.ReadNestedIntFromTF(d, SidecarResourcesFieldName, "proxy_init_limits_memory", 0)
	proxyInitRequestsCpu := utils.ReadNestedIntFromTF(d, SidecarResourcesFieldName, "proxy_init_requests_cpu", 0)
	proxyInitRequestsMemory := utils.ReadNestedIntFromTF(d, SidecarResourcesFieldName, "proxy_init_requests_memory", 0)
	proxyLimitsCpu := utils.ReadNestedIntFromTF(d, SidecarResourcesFieldName, "proxy_limits_cpu", 0)
	proxyLimitsMemory := utils.ReadNestedIntFromTF(d, SidecarResourcesFieldName, "proxy_limits_memory", 0)
	proxyRequestsCpu := utils.ReadNestedIntFromTF(d, SidecarResourcesFieldName, "proxy_requests_cpu", 0)
	proxyRequestsMemory := utils.ReadNestedIntFromTF(d, SidecarResourcesFieldName, "proxy_requests_memory", 0)
	cluster.SidecarsResources = &escherModel.SidecarsResource{
		ProxyInitLimitsCPU:      int64(proxyInitLimitsCpu),
		ProxyInitLimitsMemory:   int64(proxyInitLimitsMemory),
		ProxyInitRequestsCPU:    int64(proxyInitRequestsCpu),
		ProxyInitRequestsMemory: int64(proxyInitRequestsMemory),
		ProxyLimitsCPU:          int64(proxyLimitsCpu),
		ProxyLimitsMemory:       int64(proxyLimitsMemory),
		ProxyRequestCPU:         int64(proxyRequestsCpu),
		ProxyRequestMemory:      int64(proxyRequestsMemory),
	}

	return cluster, nil
}

func downloadFile(ctx context.Context, serviceApi *escherClient.MgmtServiceApiCtx, client *http.Client, clusterId strfmt.UUID) error {
	log.Print("[DEBUG] downloading file")

	file, err := os.Create(secureCNBundleFilePath)
	if err != nil {
		return err
	}
	buffer := new(bytes.Buffer)
	err = serviceApi.DownloadKubernetesSecureCNBundle(ctx, client, buffer, clusterId)
	if err != nil {
		return err
	}

	_, err = io.Copy(file, buffer)
	if err != nil {
		return err
	}

	return nil
}

func updateMutableFields(d *schema.ResourceData, secureCNCluster *escherModel.KubernetesCluster) {
	log.Print("[DEBUG] updating mutable fields agent")

	_ = d.Set("name", secureCNCluster.Name)
	_ = d.Set("ci_image_validation", secureCNCluster.CiImageValidation)
	_ = d.Set("cd_pod_template", secureCNCluster.ClusterPodDefinitionSource == "CD")
	_ = d.Set("connections_control", secureCNCluster.EnableConnectionsControl)
	_ = d.Set("istio_version", secureCNCluster.IstioInstallationParameters.IstioVersion)
	_ = d.Set("supports_multi_cluster_communication", secureCNCluster.IsMultiCluster)
	_ = d.Set("inspect_incoming_cluster_connections", secureCNCluster.PreserveOriginalSourceIP)
	_ = d.Set("fail_close", secureCNCluster.AgentFailClose)
	_ = d.Set("persistent_storage", secureCNCluster.IsPersistent)
	_ = d.Set("external_https_proxy", secureCNCluster.ProxyConfiguration.HTTPSProxy)
	_ = d.Set("orchestration_type", secureCNCluster.OrchestrationType)
	_ = d.Set(TLSInspectionFieldName, secureCNCluster.TLSInspectionEnabled)
	_ = d.Set(TokenInjectionFieldName, secureCNCluster.TokenInjectionEnabled)
	_ = d.Set(ServiceDiscoveryIsolationFieldName, secureCNCluster.ServiceDiscoveryIsolationEnabled)
}

func validateConfig(d *schema.ResourceData) error {
	log.Printf("[DEBUG] validating config")

	isMultiCluster := d.Get(MultiClusterCommunicationSupportFieldName).(bool)
	multiClusterFolder := d.Get(MultiClusterCommunicationSupportCertsPathFieldName).(string)
	connectionsControl := d.Get(ConnectionsControlFieldName).(bool)
	inspectIncomingClusterConnections := d.Get(InspectIncomingClusterConnectionsFieldName).(bool)
	if isMultiCluster && multiClusterFolder == "" {
		return errors.New(fmt.Sprintf("invalid configuration. %s can't be empty when %s is true", MultiClusterCommunicationSupportCertsPathFieldName, MultiClusterCommunicationSupportFieldName))
	}

	if !connectionsControl && isMultiCluster {
		return errors.New(fmt.Sprintf("invalid configuration. %s is off but %s is on ", ConnectionsControlFieldName, MultiClusterCommunicationSupportFieldName))
	}

	if !connectionsControl && inspectIncomingClusterConnections {
		return errors.New(fmt.Sprintf("invalid configuration. %s is off but %s is on", MultiClusterCommunicationSupportCertsPathFieldName, InspectIncomingClusterConnectionsFieldName))
	}

	return nil
}

func updateAgent(context string, multiClusterFolder string, clusterInTerraformConfig *escherModel.KubernetesCluster, tokenInjection bool, prevIsMultiCluster bool, prevConnectionControl bool, prevAgentFailClose bool, prevIsPersistent bool, prevProxyConfiguration escherModel.ProxyConfiguration, serviceApi *escherClient.MgmtServiceApiCtx, httpClientWrapper client.HttpClientWrapper, clusterId strfmt.UUID) error {
	needsUpdate := *clusterInTerraformConfig.IsMultiCluster != prevIsMultiCluster
	needsUpdate = needsUpdate || *clusterInTerraformConfig.EnableConnectionsControl != prevConnectionControl
	needsUpdate = needsUpdate || *clusterInTerraformConfig.AgentFailClose != prevAgentFailClose
	needsUpdate = needsUpdate || *clusterInTerraformConfig.IsPersistent != prevIsPersistent
	needsUpdate = needsUpdate || *clusterInTerraformConfig.ProxyConfiguration.EnableProxy != *prevProxyConfiguration.EnableProxy
	needsUpdate = needsUpdate || clusterInTerraformConfig.ProxyConfiguration.HTTPSProxy != prevProxyConfiguration.HTTPSProxy

	if needsUpdate {
		log.Print("[DEBUG] updating agent")
		err := deleteAgent(context)
		if err != nil {
			return err
		}
		err = installAgent(nil, serviceApi, httpClientWrapper, clusterId, context, multiClusterFolder, tokenInjection)
		if err != nil {
			return err
		}
	}
	return nil
}
